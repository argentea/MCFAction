#include "auction.cuh"

#define MAXMY 0x3f3f3f3f

struct AuctionState
{
<<<<<<< HEAD
	using namespace std::chrono;
	return 1000.0 * high_resolution_clock::period::num / high_resolution_clock::period::den;
}
__device__ int kflag;
#if DEBUG
__device__ int tans;
#endif
__device__ int minRise;
__device__ int kpoCount;
__device__ int knaCount;
__device__ int kpushListPo[SIZE][3];
__device__ int kpushListNa[SIZE][3];
__device__ bool knodesRisePrice[SIZE];
__device__ void kcheck(
		const int* kg,
		int lnodes,
		int rnodes
		){
	for(int i = lnodes; i < rnodes; i++){
		if(kg[i] != 0){
			atomicAnd(&kflag, 0);
		}
	}
	__syncthreads();
}
__device__ void printNodes(const int* nodes, int numNodes, const char* name){
	printf("*******************\n");
	printf(name);
	printf("\n");
	for(int i = 0; i < numNodes; i++){
		printf("%d\t", nodes[i]);
	}
	printf("\n*******************\n");
}
__device__ void printGraph(const int* graph, int numNodes, const char* name){
	printf("*******************\n");
	printf("%d", numNodes);
	printf(name);
//	for(int i = 0; i < numNodes; i++){
//		for(int j = 0; j < numNodes; j++){
//			printf("%d\t", graph[i*numNodes + j]);
//		}
//		printf("\n");
//	}
	printf("*******************\n");
}
=======
    int* kpushListPo; ///< length of #edges
    int* kpushListNa; ///< length of #edges
    bool* knodesRisePrice; ///< length of #nodes 

    void initialize(Graph const& G)
    {
        printf("initialize state with %d nodes\n", G.getNodesNum());
        kpushListPo = nullptr; 
        kpushListNa = nullptr; 
        knodesRisePrice = nullptr; 

        cudaError_t status = cudaMalloc((void **)&kpushListPo, G.getEdgesNum()*sizeof(int));
        if (status != cudaSuccess) 
        { 
            printf("cudaMalloc failed for kpushListPo\n"); 
        } 
        status = cudaMalloc((void **)&kpushListNa, G.getEdgesNum()*sizeof(int));
        if (status != cudaSuccess) 
        { 
            printf("cudaMalloc failed for kpushListNa\n"); 
        } 
        status = cudaMalloc((void **)&knodesRisePrice, G.getNodesNum()*sizeof(bool));
        if (status != cudaSuccess) 
        { 
            printf("cudaMalloc failed for knodesRisePrice\n"); 
        } 
    }

    void destroy()
    {
        cudaFree(kpushListPo);
        cudaFree(kpushListNa); 
        cudaFree(knodesRisePrice);
    }
};
>>>>>>> class

//pushlist is not good
__device__ void pushFlow(
		Graph &G,
        AuctionState& state, 
		const int lnodes,
		const int rnodes,
        const int node_step, 
		const int ledges,
		const int redges,
        const int edge_step, 
		const int epsilon,
		const int knumNodes, 
        int& kpoCount, 
        int& knaCount
		){
#if FULLDEBUG
	if(threadIdx.x ==0){
		printf("in pushFlow\n");
	}
	__syncthreads();
#endif
	if(threadIdx.x ==0){
		kpoCount = 0;
		knaCount = 0;
	}
	__syncthreads();

	for(int i = ledges; i < redges; i += edge_step){
		int ti,tj,tindex;
<<<<<<< HEAD
		ti = kedges[i*2 + 0];
		tj = kedges[i*2 + 1];
		if(kcost[i] - kprice[ti] + kprice[tj] + epsilon == 0&&kg[ti] >0){
			tindex = atomicAdd(&kpoCount, 1);
			kpushListPo[tindex][0] = ti;
			kpushListPo[tindex][1] = tj;
			kpushListPo[tindex][2] = i;
			continue;
		}
		if(kcost[i] - kprice[ti] + kprice[tj] - epsilon == 0&&kg[tj] > 0){
			tindex = atomicAdd(&knaCount, 1);
			kpushListNa[tindex][0] = tj;
			kpushListNa[tindex][1] = ti;
			kpushListNa[tindex][2] = i;
			continue;
=======
        auto const& edge = G.edge(i); 
		ti = edge.source;
		tj = edge.sink;
        int value = G.atCost(i) - G.atPrice(ti) + G.atPrice(tj);
		if(value + epsilon == 0 && G.atGrow(ti) >0){
			tindex = atomicAdd(&kpoCount, 1);
            state.kpushListPo[tindex] = i; 
            //int tindexx3 = tindex * 3; 
			//state.kpushListPo[tindexx3 + 0] = ti;
			//state.kpushListPo[tindexx3 + 1] = tj;
			//state.kpushListPo[tindexx3 + 2] = i;
		}
		else if (value - epsilon == 0 && G.atGrow(tj) > 0){
			tindex = atomicAdd(&knaCount, 1);
            state.kpushListNa[tindex] = i; 
            //int tindexx3 = tindex * 3; 
			//state.kpushListNa[tindexx3 + 0] = tj;
			//state.kpushListNa[tindexx3 + 1] = ti;
			//state.kpushListNa[tindexx3 + 2] = i;
>>>>>>> class
		}
	}
#if FULLDEBUG
	if(threadIdx.x ==0){
		printf("get pushList\n");
	}
	__syncthreads();
#endif
<<<<<<< HEAD
	int delta,tmpi,tmpj,edgeid;
	if(threadIdx.x == 0){
		for(int i = 0; i < kpoCount; i++){
			tmpi = kpushListPo[i][0];
			tmpj = kpushListPo[i][1];
			edgeid = kpushListPo[i][2];
			delta = min(kg[tmpi], krb[edgeid] - kflow[edgeid]);
			kflow[edgeid] += delta;
			kg[tmpi] -= delta;
			kg[tmpj] += delta;
		}
		for(int i = 0; i < knaCount; i++){
			tmpi = kpushListNa[i][0];
			tmpj = kpushListNa[i][1];
			edgeid = kpushListNa[i][2];
			delta = min(kg[tmpi], kflow[edgeid] - klb[edgeid]);
			kflow[edgeid] -= delta;
			kg[tmpi] -= delta;
			kg[tmpj] += delta;
=======
	__syncthreads();
	int delta,tmpi,tmpj,tmpk;
	if(threadIdx.x == 0){
		for(int i = 0; i < kpoCount; i++){
            tmpk = state.kpushListPo[i]; 
            auto const& edge = G.edge(tmpk); 
            tmpi = edge.source; 
            tmpj = edge.sink; 
			delta = min(G.atGrow(tmpi), G.atRb(tmpk) - G.atFlow(tmpk));
			G.setFlow(tmpk, G.atFlow(tmpk) + delta);
			G.atomicSubGrow(tmpi, delta);
			G.atomicAddGrow(tmpj, delta);
		}
		for(int i = 0; i < knaCount; i++){
            tmpk = state.kpushListNa[i]; 
            auto const& edge = G.edge(tmpk); 
            tmpi = edge.sink; 
            tmpj = edge.source; 
			delta = min(G.atGrow(tmpi), G.atFlow(tmpk) - G.atLb(tmpk));
			G.setFlow(tmpk, G.atFlow(tmpk) - delta);
			G.atomicSubGrow(tmpi, delta);
			G.atomicAddGrow(tmpj, delta);
>>>>>>> class
		}
	}
	__syncthreads();
#if FULLDEBUG
		if(threadIdx.x == 0){
			printf("out pushFlow\n");
		}
		__syncthreads();
#endif

	return ;
}
__device__ void priceRise(
		Graph &G,
        AuctionState& state, 
		const int lnodes,
		const int rnodes,
        const int node_step, 
		const int ledges,
		const int redges,
        const int edge_step, 
		const int epsilon,
		const int knumNodes, 
        int& minRise
		){
#if FULLDEBUG
		if(threadIdx.x == 0){
			printf("in priceRise\n");
		}
		__syncthreads();
#endif

	int ti,tj,tmpa,tmpb;
<<<<<<< HEAD
	for(int i = lnodes; i < rnodes; i++){
		if(kg[i] > 0){
			knodesRisePrice[i] = true;
=======
	for(int i = lnodes; i < rnodes; i += node_step){
		if(G.atGrow(i) > 0){
			state.knodesRisePrice[i] = true;
>>>>>>> class
		}else {
			state.knodesRisePrice[i] = false;
		}
	}
	__syncthreads();
<<<<<<< HEAD
	for(int i = ledges; i < redges; i++){
		ti = edges[i*2 + 0];
		tj = edges[i*2 + 1];
		if(knodesRisePrice[ti]!=knodesRisePrice[tj]){
			if(kflow[i] < krb[i] && !knodesRisePrice[tj]){
				tmpb = kprice[tj] + kcost[i] + epsilon - kprice[ti];
=======
	for(int i = ledges; i < redges; i += edge_step){
        auto const& edge = G.edge(i);
		ti = edge.source;
		tj = edge.sink;
		if(state.knodesRisePrice[ti] != state.knodesRisePrice[tj]){
			if(G.atFlow(i) < G.atRb(i) && state.knodesRisePrice[ti]){
				tmpb = G.atPrice(tj) + G.atCost(i) + epsilon - G.atPrice(ti);
>>>>>>> class
				if(tmpb >= 0){
					atomicMin(&minRise, tmpb);
				}
			}
<<<<<<< HEAD
			if(kflow[i] > klb[i] && knodesRisePrice[tj]){
				tmpa = kprice[ti] - kcost[i] + epsilon - kprice[tj];
=======
			if(G.atFlow(i) > G.atLb(i) && state.knodesRisePrice[tj]){
				tmpa = G.atPrice(ti) - G.atCost(i) + epsilon - G.atPrice(tj);
>>>>>>> class
				if(tmpa >= 0){
					atomicMin(&minRise, tmpa);
				}
			}
		}
	}
#if FULLDEBUG
		if(threadIdx.x == 0){
			printf("out priceRise\n");
		}
		__syncthreads();
#endif
	__syncthreads();

}
__global__ void __launch_bounds__(1024)
auction_algorithm_kernel(
		Graph G, 
        AuctionState state 
){
	__shared__ int kepsilon;
	__shared__ int totalIteratorNum;
	__shared__ int iteratorNum;
	__shared__ int scalingFactor;
	__shared__ int costScale;
	__shared__ int gdelta;
	__shared__ int knumNodes;
	__shared__ int knumEdges;
	__shared__ int edgesDivThread;
	__shared__ int nodesDivThread;
    __shared__ int kflag; 
    __shared__ int minRise;
    __shared__ int kpoCount;
    __shared__ int knaCount;
#if DEBUG
    __shared__ int tans;
#endif

	const int threadId = threadIdx.x;
    if (threadId == 0) {
        kepsilon = 1; 
        totalIteratorNum = 0; 
        iteratorNum = 0; 
        scalingFactor = 2; 
        costScale = 9; 
        gdelta = 0; 
        knumNodes = G.getNodesNum();
        knumEdges = G.getEdgesNum();
        edgesDivThread = max(knumEdges / blockDim.x, 1);
        nodesDivThread = max(knumNodes / blockDim.x, 1);

		printf("in kernel\n");
    }
    __syncthreads();

	//[edgesl,edgesr) is the range of edges that the thread produre
	const int ledges = threadId * edgesDivThread;
	const int redges = min(ledges + edgesDivThread, knumEdges);
    const int edge_step = 1; 

	const int lnodes = threadId * nodesDivThread;
	const int rnodes = min(lnodes + nodesDivThread, knumNodes);
    const int node_step = 1; 

	int kti;
	int ktj;

<<<<<<< HEAD
	edgesDivThread = knumEdges/kthreadNum;
	edgesModThread = knumEdges%kthreadNum;
	
	if(threadId < edgesModThread){
		ledges = threadId*(edgesDivThread + 1);
		redges = (threadId + 1)*(edgesDivThread + 1);
	}else {
		ledges = threadId*edgesDivThread + edgesModThread;
		redges = (threadId + 1)*edgesDivThread + edgesModThread;
	}
	
	nodesDivThread = knumNodes/kthreadNum;
	nodesModThread = knumNodes%kthreadNum;

	if(threadId < nodesModThread){
		lnodes = threadId*(nodesDivThread + 1);
		rnodes = (threadId + 1)*(nodesDivThread + 1);
	}else{
		lnodes = threadId*nodesDivThread + nodesModThread;
		rnodes = (threadId + 1)*nodesDivThread + nodesModThread;
	}
#if FULLDEBUG
	printf("threadId: %d, ledges: %d, redges: %d\n", threadId, ledges, redges);
	__syncthreads();
	for(int i = ledges; i < redges; i++){
		kflow[i] = atomicAdd(&justForTest, 1);
		printf("%d\n", kflow[i]);
	}
	__syncthreads();
#endif
=======
>>>>>>> class
	while(costScale >= 0){
#if DEBUG
		if(threadId == 0){
			printf("cost scale: %d\n",costScale);
		}
		__syncthreads();
#endif
		for(int i = lnodes; i < rnodes; i += node_step){
			G.setGrow(i , G.atGrowRaw(i));
		}

		int ktmp = 1<<costScale;

<<<<<<< HEAD
		for(int i = ledges; i < redges; i++){
			kflow[i] = 0;
			kcost[i] = kcostRaw[i]/ktmp;
=======
		for(int i = ledges; i < redges; i += edge_step){
			G.setFlow(i, 0);
			if(G.atCostRaw(i) <= G.getMaxCost()){
				G.setCost(i, G.atCostRaw(i)/ktmp);
			}
>>>>>>> class
		}
		for(int i = lnodes; i < rnodes; i++){
			G.setPrice(i, G.atPrice(i)*(1 << gdelta));
		}
		__syncthreads();
<<<<<<< HEAD
		for(int i = ledges; i < redges; i++){
				kti = kedges[i*2 + 0];
				ktj = kedges[i*2 + 1];
				//todo
				if(kcost[i] - kprice[kti] + kprice[ktj] + kepsilon <= 0){
					atomicSub(kg + kti, krb[i]);
					atomicAdd(kg + ktj, krb[i]);
					kflow[i] = krb[i];
				}
		}
#if FULLDEBUG
		if(threadId == 0){
			printNodes(kg, knumNodes, "kg cycle init0");
=======
		for(int i = ledges; i < redges; i += edge_step){
            auto const& edge = G.edge(i);
			kti = edge.source;
			ktj = edge.sink;
			if(G.atCost(i) - G.atPrice(kti) + G.atPrice(ktj) + kepsilon <= 0){
				G.atomicSubGrow(kti, G.atRb(i));
				G.atomicAddGrow(ktj, G.atRb(i));
				G.setFlow(i, G.atRb(i));
			}
>>>>>>> class
		}
		if(threadId == 0)
		{
            iteratorNum = 0;
			kflag = true;
		}
		__syncthreads();

		for(int i = lnodes; i < rnodes; i += node_step){
			if(G.atGrow(i) != 0){
				atomicAnd(&kflag, 0);
			}
		}
		__syncthreads();

		while(!kflag){
#if FULLDEBUG
			if(threadId == 0){
				printf("iteration : %d\n", iteratorNum);
			}
			__syncthreads();
#endif
            pushFlow(
                    G,
                    state, 
                    lnodes,
                    rnodes,
                    node_step, 
                    ledges,
                    redges,
                    edge_step, 
                    kepsilon,
                    knumNodes, 
                    kpoCount, 
                    knaCount
                    );
			if(threadId == 0){
				minRise = MAXMY;
			}
			__syncthreads();
            priceRise(
                    G,
                    state, 
                    lnodes,
                    rnodes,
                    node_step, 
                    ledges,
                    redges,
                    edge_step, 
                    kepsilon,
                    knumNodes, 
                    minRise
                    );
			__syncthreads();
#if FULLDEBUG
			if(threadId == 0){
				printf("minRise: %d\n", minRise);
			}
			__syncthreads();
#endif
			if(threadId == 0){
				if(minRise == MAXMY){
					minRise = 0;
				}
			}

			__syncthreads();
			for(int i = lnodes; i < rnodes; i += node_step){
				if(state.knodesRisePrice[i]){
					G.setPrice(i, G.atPrice(i) + minRise);
				}
			}
			__syncthreads();
			if(threadId == 0)
			{
                iteratorNum++;
                totalIteratorNum++;
				kflag = true;
			}
			for(int i = lnodes; i < rnodes; i += node_step){
				if(G.atGrow(i) != 0){
					atomicAnd(&kflag, 0);
				}
			}
			__syncthreads();

		}

#if DEBUG
		if(threadId == 0){
			tans = 0;
		}
		__syncthreads();
<<<<<<< HEAD
		for(int i = ledges; i < redges; i++){
			kti = kedges[i*2 + 0];
			ktj = kedges[i*2 + 1];
			atomicAdd(&tans, kflow[i]*kcostRaw[i]);
=======
		for(int i = ledges; i < redges; i += edge_step){
			atomicAdd(&tans, G.atFlow(i)*G.atCostRaw(i));
>>>>>>> class
		}
		if(threadId == 0){
			printf("inner loop out: %d\n",iteratorNum);
			printf("temporary ans: %d\n",tans);
			printf("cost scale: %d\n", costScale);
			printf("iteratorNum: %d\n", iteratorNum);
		}
		__syncthreads();
#endif
		if(costScale ==0){
			break;
		}
        if (threadId == 0) {
            gdelta = costScale - max(0, costScale - scalingFactor);
            costScale = max(0, costScale - scalingFactor);
        }
        __syncthreads();
	}

	if(threadId == 0)
	{
<<<<<<< HEAD
		printGraph(kcost, knumNodes,"cost");
		printf("kenerl end: %d\n",totalIteratorNum);
=======
		printf("totalIteratorNum: %d\n", totalIteratorNum);
		printf("kenerl end\n");
>>>>>>> class
	}
}

hr_clock_rep timer_start, timer_mem, timer_stop;
void run_auction(
		Graph auctionGraph,
		int threadNum,
		int* hflow){
	std::cout << "start run_auction\n";

<<<<<<< HEAD
	timer_start = get_globaltime();
	cudaMalloc((void **)&dedges, EDGESIZE*2*sizeof(int));
	cudaMalloc((void **)&dcost, EDGESIZE*sizeof(int));
	cudaMalloc((void **)&dcostRaw, EDGESIZE*sizeof(int));

	cudaMalloc((void **)&dg, SIZE*sizeof(int));
	cudaMalloc((void **)&dgraw, SIZE*sizeof(int));
	cudaMalloc((void **)&dlb, EDGESIZE*sizeof(int));
	cudaMalloc((void **)&drb, EDGESIZE*sizeof(int));


	cudaMalloc((void **)&dprice, SIZE*sizeof(int));

	cudaMalloc((void **)&dflow, EDGESIZE*sizeof(int));


	cudaMemcpy(dedges, hedges, EDGESIZE*2*sizeof(int), cudaMemcpyHostToDevice);
	
	cudaMemcpy(dcost, hcost, EDGESIZE*sizeof(int), cudaMemcpyHostToDevice);
	cudaMemcpy(dcostRaw, hcost, EDGESIZE*sizeof(int), cudaMemcpyHostToDevice);


	cudaMemcpy(dg, hg, SIZE*sizeof(int), cudaMemcpyHostToDevice);
	cudaMemcpy(dgraw, hg, SIZE*sizeof(int), cudaMemcpyHostToDevice);

	cudaMemcpy(dlb, hlb, EDGESIZE*sizeof(int), cudaMemcpyHostToDevice);
	cudaMemcpy(drb, hrb, EDGESIZE*sizeof(int), cudaMemcpyHostToDevice);


	timer_mem = get_globaltime();
=======
>>>>>>> class
	cudaProfilerStart();
	std::cout << "start kernel\n";
    AuctionState state; 
    state.initialize(auctionGraph);
	auction_algorithm_kernel<<<1,threadNum>>>
		(
		auctionGraph, 
        state
		);
    state.destroy();
	cudaProfilerStop();
	cudaDeviceSynchronize();
	timer_stop = get_globaltime();
<<<<<<< HEAD
	cudaMemcpy(hflow, dflow, EDGESIZE*sizeof(int), cudaMemcpyDeviceToHost);
	
	int ans = 0;
//	for(int i = 0; i < numNodes; i++){
//		for(int j = 0; j < numNodes; j++){
//			ans += hflow[i*numNodes + j]*hcost[i*numNodes+ j];
//			cout << hflow[i*numNodes + j] << " ";
//		}
//	}
	cout << "ans:  " << ans << endl;

}


void initmy(
		int *dc,
		int *edges,
		int *cost,
		int *hg,
		int *lb,
		int *rb
		){
	cout << "start read in graph..\n";
	int tnumNodes;
	int tCapacity = 0;
	int tmaxCost = 0;
	cin >> tnumNodes;
	cout << "tnumNodes: "<< tnumNodes << endl;
	memset(cost, MAXMY, sizeof(cost));
	memset(edges, 0, sizeof(edges));
	memset(hg, 0, sizeof(hg));
	char a;
	int fid;
	int aNUm;
	cin >> aNUm;
//	cout << "aNUm " << aNUm << endl;
	for(int i = 0; i < aNUm; i++){
		cin >> a >> fid;
		cin >> hg[fid-1];
//		cout << a << " " << fid << " " << g[fid-1] << endl;
	}
	int ti,tj;
	int edgeNum = 0;
	while(true){
		cin >> a >> ti >> tj;
		if(ti == tj&&ti==0){
			break;
		}
		ti--;tj--;
		edges[edgeNum*2] = ti;
		edges[edgeNum*2 + 1] = tj;

		cin >> lb[edgeNum] >> rb[edgeNum] >>  cost[edgeNum] ;
//		cout << a << "\t" << ti << " " << tj << " " << cost[ti*SIZE + tj] <<" " << lb[ti*SIZE + tj] << " " << rb[ti*SIZE + tj] <<  endl;
//		cost[ti][tj] *= nodeNum;
//		cost[ti][tj] %= 4000;
		tmaxCost = max(cost[edgeNum], tmaxCost);
		tCapacity = max(rb[edgeNum], tCapacity);
		edgeNum++;
	}
	cout << "EDGENUM: " << edgeNum << endl;
	*dc = tmaxCost;
	/*
	for(int i = 0; i < edgeNum;i ++){
		printf("%d\t",cost[edges[(i * 2 + 0)]*SIZE + edges[i * 2 + 1]]);
	}
	cout << endl;
	for(int i = 0; i < edgeNum; i++){
		printf("%d\t",costa[i]);
	}
	*/
	cout << "read end\n";
=======
>>>>>>> class
}

int main(int argc, char *argv[]){
	int threadNum = 1024;
<<<<<<< HEAD
	int numNodes = SIZE;
	int numEdges = EDGESIZE;
	int hC;
	int *hedges = new int[EDGESIZE*2];
	int *hcost = new int[EDGESIZE];
	int *hg = new int[SIZE];
	int *hlb = new int[EDGESIZE];
	int *hrb = new int[EDGESIZE];

	int *hflow = new int[EDGESIZE];
	memset(hflow, 0, sizeof(hflow));

	initmy(
		&hC,
		hedges,
		hcost,
		hg,
		hlb,
		hrb
	);
=======
//	initmy(&hC,hedges,hcost,hg,hlb,hrb	);
	timer_start = get_globaltime();
	Graph auctionGraph = Graph(Graph::edgeList, argv[1]);
	timer_mem = get_globaltime();

//	Graph auctionGraph = Graph(Graph::matrix,numNodes, numEdges, hC, hedges, hcost, hlb, hrb, hg);
>>>>>>> class

    std::vector<int> hflow (auctionGraph.getNodesNum() * auctionGraph.getNodesNum(), 0);
	run_auction(
		auctionGraph,
		threadNum,
		hflow.data()
	);

	std::cerr << "run_acution takes "<< (timer_stop - timer_start)*get_timer_period() << "ms totally.\n";
	std::cerr << "memory copy takes "<< (timer_mem - timer_start)*get_timer_period() << "ms totally.\n";
	std::cerr << "kernel takes "<< (timer_stop - timer_mem)*get_timer_period() << "ms totally.\n";
	return 0;
}
