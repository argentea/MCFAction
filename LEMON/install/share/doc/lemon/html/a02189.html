<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: CycleCanceling&lt; GR, V, C &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="a00554.html">lemon</a></li><li class="navelem"><a class="el" href="a02189.html">CycleCanceling</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="a02186.html">List of all members</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a>  </div>
  <div class="headertitle">
<div class="title">CycleCanceling&lt; GR, V, C &gt; Class Template Reference<div class="ingroups"><a class="el" href="a00522.html">Algorithms</a> &raquo; <a class="el" href="a00527.html">Minimum Cost Flow Algorithms</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename GR, typename V, typename C&gt;<br />
class lemon::CycleCanceling&lt; GR, V, C &gt;</h3>

<p><a class="el" href="a02189.html">CycleCanceling</a> implements three different cycle-canceling algorithms for finding a <a class="el" href="a07262.html">minimum cost flow</a> <b>[amo93networkflows]</b>, <b>[klein67primal]</b>, <b>[goldberg89cyclecanceling]</b>. The most efficent one is the <a class="el" href="a02189.html#a2a3c0067e44c5ef3210a256d06c16b0fae5674d98ba6203a143cc02984415c242">Cancel-and-Tighten</a> algorithm, thus it is the default method. It runs in strongly polynomial time <img class="formulaInl" alt="$O(n^2 m^2 \log n)$" src="form_62.png"/>, but in practice, it is typically orders of magnitude slower than the scaling algorithms and <a class="el" href="a03889.html">NetworkSimplex</a>. (For more information, see <a class="el" href="a00527.html">the module page</a>.)</p>
<p>Most of the parameters of the problem (except for the digraph) can be given using separate functions, and the algorithm can be executed using the <a class="el" href="a02189.html#ad63980373b4e743a2827d0a6a0316205">run()</a> function. If some parameters are not specified, then default values will be used.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">GR</td><td>The digraph type the algorithm runs on. </td></tr>
    <tr><td class="paramname">V</td><td>The number type used for flow amounts, capacity bounds and supply values in the algorithm. By default, it is <code>int</code>. </td></tr>
    <tr><td class="paramname">C</td><td>The number type used for costs and potentials in the algorithm. By default, it is the same as <code>V</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Both <code>V</code> and <code>C</code> must be signed number types. </dd>
<dd>
All input data (capacities, supply values, and costs) must be integer. </dd>
<dd>
This algorithm does not support negative costs for arcs having infinite upper bound.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>For more information about the three available methods, see <a class="el" href="a02189.html#a2a3c0067e44c5ef3210a256d06c16b0f">Method</a>. </dd></dl>
</div>
<p><code>#include &lt;lemon/cycle_canceling.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a4c669cb1cb4d98dfea944e9ceec7d33e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02189.html#a4c669cb1cb4d98dfea944e9ceec7d33e">ProblemType</a> { <a class="el" href="a02189.html#a4c669cb1cb4d98dfea944e9ceec7d33ea2884fa43446c0cbc9c7a9b74d41d7483">INFEASIBLE</a>, 
<a class="el" href="a02189.html#a4c669cb1cb4d98dfea944e9ceec7d33ea2579881e7c83261bc21bafb5a5c92cad">OPTIMAL</a>, 
<a class="el" href="a02189.html#a4c669cb1cb4d98dfea944e9ceec7d33ea6c65123d1b5b01632a477661055b01ef">UNBOUNDED</a>
 }</td></tr>
<tr class="memdesc:a4c669cb1cb4d98dfea944e9ceec7d33e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Problem type constants for the <code><a class="el" href="a02189.html#ad63980373b4e743a2827d0a6a0316205" title="Run the algorithm.">run()</a></code> function.  <a href="a02189.html#a4c669cb1cb4d98dfea944e9ceec7d33e">More...</a><br /></td></tr>
<tr class="separator:a4c669cb1cb4d98dfea944e9ceec7d33e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a3c0067e44c5ef3210a256d06c16b0f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02189.html#a2a3c0067e44c5ef3210a256d06c16b0f">Method</a> { <a class="el" href="a02189.html#a2a3c0067e44c5ef3210a256d06c16b0fa0ebf9c5c0bd3e01f5a9060478d2a7baa">SIMPLE_CYCLE_CANCELING</a>, 
<a class="el" href="a02189.html#a2a3c0067e44c5ef3210a256d06c16b0fad8e15d52edef3c0ff3d27acefd621818">MINIMUM_MEAN_CYCLE_CANCELING</a>, 
<a class="el" href="a02189.html#a2a3c0067e44c5ef3210a256d06c16b0fae5674d98ba6203a143cc02984415c242">CANCEL_AND_TIGHTEN</a>
 }</td></tr>
<tr class="memdesc:a2a3c0067e44c5ef3210a256d06c16b0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constants for selecting the used method.  <a href="a02189.html#a2a3c0067e44c5ef3210a256d06c16b0f">More...</a><br /></td></tr>
<tr class="separator:a2a3c0067e44c5ef3210a256d06c16b0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af108349b07bd3b361cfa1387c19395ac"><td class="memItemLeft" align="right" valign="top"><a id="af108349b07bd3b361cfa1387c19395ac"></a>
typedef GR&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02189.html#af108349b07bd3b361cfa1387c19395ac">Digraph</a></td></tr>
<tr class="memdesc:af108349b07bd3b361cfa1387c19395ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the digraph. <br /></td></tr>
<tr class="separator:af108349b07bd3b361cfa1387c19395ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c1768456283cc436140a9ffae849dd2"><td class="memItemLeft" align="right" valign="top"><a id="a6c1768456283cc436140a9ffae849dd2"></a>
typedef V&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02189.html#a6c1768456283cc436140a9ffae849dd2">Value</a></td></tr>
<tr class="memdesc:a6c1768456283cc436140a9ffae849dd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the flow amounts, capacity bounds and supply values. <br /></td></tr>
<tr class="separator:a6c1768456283cc436140a9ffae849dd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adeb81a88e6bbaf933ca20ea3bbba7a2c"><td class="memItemLeft" align="right" valign="top"><a id="adeb81a88e6bbaf933ca20ea3bbba7a2c"></a>
typedef C&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02189.html#adeb81a88e6bbaf933ca20ea3bbba7a2c">Cost</a></td></tr>
<tr class="memdesc:adeb81a88e6bbaf933ca20ea3bbba7a2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the arc costs. <br /></td></tr>
<tr class="separator:adeb81a88e6bbaf933ca20ea3bbba7a2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a9781d9ac0d763defc63815da06b4b2b2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02189.html#a9781d9ac0d763defc63815da06b4b2b2">CycleCanceling</a> (const GR &amp;graph)</td></tr>
<tr class="memdesc:a9781d9ac0d763defc63815da06b4b2b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="a02189.html#a9781d9ac0d763defc63815da06b4b2b2">More...</a><br /></td></tr>
<tr class="separator:a9781d9ac0d763defc63815da06b4b2b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Parameters</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>The parameters of the algorithm can be specified using these functions. </p>
</div></td></tr>
<tr class="memitem:a980391a01f804f1cd14ac58f365a07af"><td class="memTemplParams" colspan="2">template&lt;typename LowerMap &gt; </td></tr>
<tr class="memitem:a980391a01f804f1cd14ac58f365a07af"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a02189.html">CycleCanceling</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a02189.html#a980391a01f804f1cd14ac58f365a07af">lowerMap</a> (const LowerMap &amp;map)</td></tr>
<tr class="memdesc:a980391a01f804f1cd14ac58f365a07af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the lower bounds on the arcs.  <a href="a02189.html#a980391a01f804f1cd14ac58f365a07af">More...</a><br /></td></tr>
<tr class="separator:a980391a01f804f1cd14ac58f365a07af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ab69fe04cb7b7ad1bd77acec2c94d46"><td class="memTemplParams" colspan="2">template&lt;typename UpperMap &gt; </td></tr>
<tr class="memitem:a0ab69fe04cb7b7ad1bd77acec2c94d46"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a02189.html">CycleCanceling</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a02189.html#a0ab69fe04cb7b7ad1bd77acec2c94d46">upperMap</a> (const UpperMap &amp;map)</td></tr>
<tr class="memdesc:a0ab69fe04cb7b7ad1bd77acec2c94d46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the upper bounds (capacities) on the arcs.  <a href="a02189.html#a0ab69fe04cb7b7ad1bd77acec2c94d46">More...</a><br /></td></tr>
<tr class="separator:a0ab69fe04cb7b7ad1bd77acec2c94d46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac890c26d5ecc26854000d2c1e61b8f9b"><td class="memTemplParams" colspan="2">template&lt;typename CostMap &gt; </td></tr>
<tr class="memitem:ac890c26d5ecc26854000d2c1e61b8f9b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a02189.html">CycleCanceling</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a02189.html#ac890c26d5ecc26854000d2c1e61b8f9b">costMap</a> (const CostMap &amp;map)</td></tr>
<tr class="memdesc:ac890c26d5ecc26854000d2c1e61b8f9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the costs of the arcs.  <a href="a02189.html#ac890c26d5ecc26854000d2c1e61b8f9b">More...</a><br /></td></tr>
<tr class="separator:ac890c26d5ecc26854000d2c1e61b8f9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29931e78b92a8e36cf376da50c3d8abb"><td class="memTemplParams" colspan="2">template&lt;typename SupplyMap &gt; </td></tr>
<tr class="memitem:a29931e78b92a8e36cf376da50c3d8abb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a02189.html">CycleCanceling</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a02189.html#a29931e78b92a8e36cf376da50c3d8abb">supplyMap</a> (const SupplyMap &amp;map)</td></tr>
<tr class="memdesc:a29931e78b92a8e36cf376da50c3d8abb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the supply values of the nodes.  <a href="a02189.html#a29931e78b92a8e36cf376da50c3d8abb">More...</a><br /></td></tr>
<tr class="separator:a29931e78b92a8e36cf376da50c3d8abb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad267c7b64da13dfafef5efb8cf9e1671"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a02189.html">CycleCanceling</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02189.html#ad267c7b64da13dfafef5efb8cf9e1671">stSupply</a> (const Node &amp;s, const Node &amp;t, <a class="el" href="a02189.html#a6c1768456283cc436140a9ffae849dd2">Value</a> k)</td></tr>
<tr class="memdesc:ad267c7b64da13dfafef5efb8cf9e1671"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set single source and target nodes and a supply value.  <a href="a02189.html#ad267c7b64da13dfafef5efb8cf9e1671">More...</a><br /></td></tr>
<tr class="separator:ad267c7b64da13dfafef5efb8cf9e1671"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Execution control</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>The algorithm can be executed using <a class="el" href="a02189.html#ad63980373b4e743a2827d0a6a0316205">run()</a>. </p>
</div></td></tr>
<tr class="memitem:ad63980373b4e743a2827d0a6a0316205"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a02189.html#a4c669cb1cb4d98dfea944e9ceec7d33e">ProblemType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02189.html#ad63980373b4e743a2827d0a6a0316205">run</a> (<a class="el" href="a02189.html#a2a3c0067e44c5ef3210a256d06c16b0f">Method</a> method=<a class="el" href="a02189.html#a2a3c0067e44c5ef3210a256d06c16b0fae5674d98ba6203a143cc02984415c242">CANCEL_AND_TIGHTEN</a>)</td></tr>
<tr class="memdesc:ad63980373b4e743a2827d0a6a0316205"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run the algorithm.  <a href="a02189.html#ad63980373b4e743a2827d0a6a0316205">More...</a><br /></td></tr>
<tr class="separator:ad63980373b4e743a2827d0a6a0316205"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b5551dde2821381f3828bfd342cede8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a02189.html">CycleCanceling</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02189.html#a1b5551dde2821381f3828bfd342cede8">resetParams</a> ()</td></tr>
<tr class="memdesc:a1b5551dde2821381f3828bfd342cede8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset all the parameters that have been given before.  <a href="a02189.html#a1b5551dde2821381f3828bfd342cede8">More...</a><br /></td></tr>
<tr class="separator:a1b5551dde2821381f3828bfd342cede8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a9b71f0934567a8887a6e8c213e759b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a02189.html">CycleCanceling</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02189.html#a9a9b71f0934567a8887a6e8c213e759b">reset</a> ()</td></tr>
<tr class="memdesc:a9a9b71f0934567a8887a6e8c213e759b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the internal data structures and all the parameters that have been given before.  <a href="a02189.html#a9a9b71f0934567a8887a6e8c213e759b">More...</a><br /></td></tr>
<tr class="separator:a9a9b71f0934567a8887a6e8c213e759b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Query Functions</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>The results of the algorithm can be obtained using these functions.<br  />
The <a class="el" href="a02189.html#ad63980373b4e743a2827d0a6a0316205">run()</a> function must be called before using them. </p>
</div></td></tr>
<tr class="memitem:a484c946e8ad38f8c0b419c84637140d2"><td class="memTemplParams" colspan="2">template&lt;typename Number &gt; </td></tr>
<tr class="memitem:a484c946e8ad38f8c0b419c84637140d2"><td class="memTemplItemLeft" align="right" valign="top">Number&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a02189.html#a484c946e8ad38f8c0b419c84637140d2">totalCost</a> () const</td></tr>
<tr class="memdesc:a484c946e8ad38f8c0b419c84637140d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the total cost of the found flow.  <a href="a02189.html#a484c946e8ad38f8c0b419c84637140d2">More...</a><br /></td></tr>
<tr class="separator:a484c946e8ad38f8c0b419c84637140d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a77ac91887d3ea35df58e98b13e6fd4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a02189.html#a6c1768456283cc436140a9ffae849dd2">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02189.html#a1a77ac91887d3ea35df58e98b13e6fd4">flow</a> (const Arc &amp;a) const</td></tr>
<tr class="memdesc:a1a77ac91887d3ea35df58e98b13e6fd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the flow on the given arc.  <a href="a02189.html#a1a77ac91887d3ea35df58e98b13e6fd4">More...</a><br /></td></tr>
<tr class="separator:a1a77ac91887d3ea35df58e98b13e6fd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2ea9eb67aee0565ecdbaeb537eb8b46"><td class="memTemplParams" colspan="2">template&lt;typename FlowMap &gt; </td></tr>
<tr class="memitem:aa2ea9eb67aee0565ecdbaeb537eb8b46"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a02189.html#aa2ea9eb67aee0565ecdbaeb537eb8b46">flowMap</a> (FlowMap &amp;map) const</td></tr>
<tr class="memdesc:aa2ea9eb67aee0565ecdbaeb537eb8b46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the flow values (the primal solution) into the given map.  <a href="a02189.html#aa2ea9eb67aee0565ecdbaeb537eb8b46">More...</a><br /></td></tr>
<tr class="separator:aa2ea9eb67aee0565ecdbaeb537eb8b46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac291424bc8234750625d26b984442150"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a02189.html#adeb81a88e6bbaf933ca20ea3bbba7a2c">Cost</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02189.html#ac291424bc8234750625d26b984442150">potential</a> (const Node &amp;n) const</td></tr>
<tr class="memdesc:ac291424bc8234750625d26b984442150"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the potential (dual value) of the given node.  <a href="a02189.html#ac291424bc8234750625d26b984442150">More...</a><br /></td></tr>
<tr class="separator:ac291424bc8234750625d26b984442150"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c1faa3dd3a44ffe90e51af832ec7804"><td class="memTemplParams" colspan="2">template&lt;typename PotentialMap &gt; </td></tr>
<tr class="memitem:a0c1faa3dd3a44ffe90e51af832ec7804"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a02189.html#a0c1faa3dd3a44ffe90e51af832ec7804">potentialMap</a> (PotentialMap &amp;map) const</td></tr>
<tr class="memdesc:a0c1faa3dd3a44ffe90e51af832ec7804"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the potential values (the dual solution) into the given map.  <a href="a02189.html#a0c1faa3dd3a44ffe90e51af832ec7804">More...</a><br /></td></tr>
<tr class="separator:a0c1faa3dd3a44ffe90e51af832ec7804"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a601ffd79f13610daacadd46f973507c5"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a02189.html#a6c1768456283cc436140a9ffae849dd2">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02189.html#a601ffd79f13610daacadd46f973507c5">INF</a></td></tr>
<tr class="memdesc:a601ffd79f13610daacadd46f973507c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant for infinite upper bounds (capacities).  <a href="a02189.html#a601ffd79f13610daacadd46f973507c5">More...</a><br /></td></tr>
<tr class="separator:a601ffd79f13610daacadd46f973507c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a4c669cb1cb4d98dfea944e9ceec7d33e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c669cb1cb4d98dfea944e9ceec7d33e">&#9670;&nbsp;</a></span>ProblemType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="a02189.html#a4c669cb1cb4d98dfea944e9ceec7d33e">ProblemType</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enum type containing the problem type constants that can be returned by the <a class="el" href="a02189.html#ad63980373b4e743a2827d0a6a0316205">run()</a> function of the algorithm. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a4c669cb1cb4d98dfea944e9ceec7d33ea2884fa43446c0cbc9c7a9b74d41d7483"></a>INFEASIBLE&#160;</td><td class="fielddoc"><p>The problem has no feasible solution (flow). </p>
</td></tr>
<tr><td class="fieldname"><a id="a4c669cb1cb4d98dfea944e9ceec7d33ea2579881e7c83261bc21bafb5a5c92cad"></a>OPTIMAL&#160;</td><td class="fielddoc"><p>The problem has optimal solution (i.e. it is feasible and bounded), and the algorithm has found optimal flow and node potentials (primal and dual solutions). </p>
</td></tr>
<tr><td class="fieldname"><a id="a4c669cb1cb4d98dfea944e9ceec7d33ea6c65123d1b5b01632a477661055b01ef"></a>UNBOUNDED&#160;</td><td class="fielddoc"><p>The digraph contains an arc of negative cost and infinite upper bound. It means that the objective function is unbounded on that arc, however, note that it could actually be bounded over the feasible flows, but this algroithm cannot handle these cases. </p>
</td></tr>
</table>

</div>
</div>
<a id="a2a3c0067e44c5ef3210a256d06c16b0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a3c0067e44c5ef3210a256d06c16b0f">&#9670;&nbsp;</a></span>Method</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="a02189.html#a2a3c0067e44c5ef3210a256d06c16b0f">Method</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enum type containing constants for selecting the used method for the <a class="el" href="a02189.html#ad63980373b4e743a2827d0a6a0316205">run()</a> function.</p>
<p><a class="el" href="a02189.html">CycleCanceling</a> provides three different cycle-canceling methods. By default, <a class="el" href="a02189.html#a2a3c0067e44c5ef3210a256d06c16b0fae5674d98ba6203a143cc02984415c242">Cancel-and-Tighten</a> is used, which is by far the most efficient and the most robust. However, the other methods can be selected using the <a class="el" href="a02189.html#ad63980373b4e743a2827d0a6a0316205">run()</a> function with the proper parameter. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a2a3c0067e44c5ef3210a256d06c16b0fa0ebf9c5c0bd3e01f5a9060478d2a7baa"></a>SIMPLE_CYCLE_CANCELING&#160;</td><td class="fielddoc"><p>A simple cycle-canceling method, which uses the <a class="el" href="a01657.html">Bellman-Ford</a> algorithm for detecting negative cycles in the residual network. The number of Bellman-Ford iterations is bounded by a successively increased limit. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2a3c0067e44c5ef3210a256d06c16b0fad8e15d52edef3c0ff3d27acefd621818"></a>MINIMUM_MEAN_CYCLE_CANCELING&#160;</td><td class="fielddoc"><p>The "Minimum Mean Cycle-Canceling" algorithm, which is a well-known strongly polynomial method <b>[goldberg89cyclecanceling]</b>. It improves along a <a class="el" href="a00529.html">minimum mean cycle</a> in each iteration. Its running time complexity is <img class="formulaInl" alt="$O(n^2 m^3 \log n)$" src="form_63.png"/>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2a3c0067e44c5ef3210a256d06c16b0fae5674d98ba6203a143cc02984415c242"></a>CANCEL_AND_TIGHTEN&#160;</td><td class="fielddoc"><p>The "Cancel-and-Tighten" algorithm, which can be viewed as an improved version of the previous method <b>[goldberg89cyclecanceling]</b>. It is faster both in theory and in practice, its running time complexity is <img class="formulaInl" alt="$O(n^2 m^2 \log n)$" src="form_62.png"/>. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a9781d9ac0d763defc63815da06b4b2b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9781d9ac0d763defc63815da06b4b2b2">&#9670;&nbsp;</a></span>CycleCanceling()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a02189.html">CycleCanceling</a> </td>
          <td>(</td>
          <td class="paramtype">const GR &amp;&#160;</td>
          <td class="paramname"><em>graph</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The constructor of the class.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td>The digraph the algorithm runs on. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a980391a01f804f1cd14ac58f365a07af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a980391a01f804f1cd14ac58f365a07af">&#9670;&nbsp;</a></span>lowerMap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a02189.html">CycleCanceling</a>&amp; lowerMap </td>
          <td>(</td>
          <td class="paramtype">const LowerMap &amp;&#160;</td>
          <td class="paramname"><em>map</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function sets the lower bounds on the arcs. If it is not used before calling <a class="el" href="a02189.html#ad63980373b4e743a2827d0a6a0316205">run()</a>, the lower bounds will be set to zero on all arcs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">map</td><td>An arc map storing the lower bounds. Its <code>Value</code> type must be convertible to the <code>Value</code> type of the algorithm.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>(*this)</code> </dd></dl>

</div>
</div>
<a id="a0ab69fe04cb7b7ad1bd77acec2c94d46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ab69fe04cb7b7ad1bd77acec2c94d46">&#9670;&nbsp;</a></span>upperMap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a02189.html">CycleCanceling</a>&amp; upperMap </td>
          <td>(</td>
          <td class="paramtype">const UpperMap &amp;&#160;</td>
          <td class="paramname"><em>map</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function sets the upper bounds (capacities) on the arcs. If it is not used before calling <a class="el" href="a02189.html#ad63980373b4e743a2827d0a6a0316205">run()</a>, the upper bounds will be set to <a class="el" href="a02189.html#a601ffd79f13610daacadd46f973507c5">INF</a> on all arcs (i.e. the flow value will be unbounded from above).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">map</td><td>An arc map storing the upper bounds. Its <code>Value</code> type must be convertible to the <code>Value</code> type of the algorithm.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>(*this)</code> </dd></dl>

</div>
</div>
<a id="ac890c26d5ecc26854000d2c1e61b8f9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac890c26d5ecc26854000d2c1e61b8f9b">&#9670;&nbsp;</a></span>costMap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a02189.html">CycleCanceling</a>&amp; costMap </td>
          <td>(</td>
          <td class="paramtype">const CostMap &amp;&#160;</td>
          <td class="paramname"><em>map</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function sets the costs of the arcs. If it is not used before calling <a class="el" href="a02189.html#ad63980373b4e743a2827d0a6a0316205">run()</a>, the costs will be set to <code>1</code> on all arcs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">map</td><td>An arc map storing the costs. Its <code>Value</code> type must be convertible to the <code>Cost</code> type of the algorithm.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>(*this)</code> </dd></dl>

</div>
</div>
<a id="a29931e78b92a8e36cf376da50c3d8abb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29931e78b92a8e36cf376da50c3d8abb">&#9670;&nbsp;</a></span>supplyMap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a02189.html">CycleCanceling</a>&amp; supplyMap </td>
          <td>(</td>
          <td class="paramtype">const SupplyMap &amp;&#160;</td>
          <td class="paramname"><em>map</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function sets the supply values of the nodes. If neither this function nor <a class="el" href="a02189.html#ad267c7b64da13dfafef5efb8cf9e1671">stSupply()</a> is used before calling <a class="el" href="a02189.html#ad63980373b4e743a2827d0a6a0316205">run()</a>, the supply of each node will be set to zero.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">map</td><td>A node map storing the supply values. Its <code>Value</code> type must be convertible to the <code>Value</code> type of the algorithm.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>(*this)</code> </dd></dl>

</div>
</div>
<a id="ad267c7b64da13dfafef5efb8cf9e1671"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad267c7b64da13dfafef5efb8cf9e1671">&#9670;&nbsp;</a></span>stSupply()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a02189.html">CycleCanceling</a>&amp; stSupply </td>
          <td>(</td>
          <td class="paramtype">const Node &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Node &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a02189.html#a6c1768456283cc436140a9ffae849dd2">Value</a>&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function sets a single source node and a single target node and the required flow value. If neither this function nor <a class="el" href="a02189.html#a29931e78b92a8e36cf376da50c3d8abb">supplyMap()</a> is used before calling <a class="el" href="a02189.html#ad63980373b4e743a2827d0a6a0316205">run()</a>, the supply of each node will be set to zero.</p>
<p>Using this function has the same effect as using <a class="el" href="a02189.html#a29931e78b92a8e36cf376da50c3d8abb">supplyMap()</a> with a map in which <code>k</code> is assigned to <code>s</code>, <code>-k</code> is assigned to <code>t</code> and all other nodes have zero supply value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The source node. </td></tr>
    <tr><td class="paramname">t</td><td>The target node. </td></tr>
    <tr><td class="paramname">k</td><td>The required amount of flow from node <code>s</code> to node <code>t</code> (i.e. the supply of <code>s</code> and the demand of <code>t</code>).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>(*this)</code> </dd></dl>

</div>
</div>
<a id="ad63980373b4e743a2827d0a6a0316205"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad63980373b4e743a2827d0a6a0316205">&#9670;&nbsp;</a></span>run()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a02189.html#a4c669cb1cb4d98dfea944e9ceec7d33e">ProblemType</a> run </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a02189.html#a2a3c0067e44c5ef3210a256d06c16b0f">Method</a>&#160;</td>
          <td class="paramname"><em>method</em> = <code><a class="el" href="a02189.html#a2a3c0067e44c5ef3210a256d06c16b0fae5674d98ba6203a143cc02984415c242">CANCEL_AND_TIGHTEN</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function runs the algorithm. The paramters can be specified using functions <a class="el" href="a02189.html#a980391a01f804f1cd14ac58f365a07af">lowerMap()</a>, <a class="el" href="a02189.html#a0ab69fe04cb7b7ad1bd77acec2c94d46">upperMap()</a>, <a class="el" href="a02189.html#ac890c26d5ecc26854000d2c1e61b8f9b">costMap()</a>, <a class="el" href="a02189.html#a29931e78b92a8e36cf376da50c3d8abb">supplyMap()</a>, <a class="el" href="a02189.html#ad267c7b64da13dfafef5efb8cf9e1671">stSupply()</a>. For example, </p><div class="fragment"><div class="line">CycleCanceling&lt;ListDigraph&gt; cc(graph);</div>
<div class="line">cc.lowerMap(lower).upperMap(upper).costMap(cost)</div>
<div class="line">  .supplyMap(sup).run();</div>
</div><!-- fragment --><p>This function can be called more than once. All the given parameters are kept for the next call, unless <a class="el" href="a02189.html#a1b5551dde2821381f3828bfd342cede8">resetParams()</a> or <a class="el" href="a02189.html#a9a9b71f0934567a8887a6e8c213e759b">reset()</a> is used, thus only the modified parameters have to be set again. If the underlying digraph was also modified after the construction of the class (or the last <a class="el" href="a02189.html#a9a9b71f0934567a8887a6e8c213e759b">reset()</a> call), then the <a class="el" href="a02189.html#a9a9b71f0934567a8887a6e8c213e759b">reset()</a> function must be called.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">method</td><td>The cycle-canceling method that will be used. For more information, see <a class="el" href="a02189.html#a2a3c0067e44c5ef3210a256d06c16b0f">Method</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>INFEASIBLE</code> if no feasible flow exists, <br  />
 <code>OPTIMAL</code> if the problem has optimal solution (i.e. it is feasible and bounded), and the algorithm has found optimal flow and node potentials (primal and dual solutions), <br  />
 <code>UNBOUNDED</code> if the digraph contains an arc of negative cost and infinite upper bound. It means that the objective function is unbounded on that arc, however, note that it could actually be bounded over the feasible flows, but this algroithm cannot handle these cases.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a02189.html#a4c669cb1cb4d98dfea944e9ceec7d33e" title="Problem type constants for the run() function.">ProblemType</a>, <a class="el" href="a02189.html#a2a3c0067e44c5ef3210a256d06c16b0f" title="Constants for selecting the used method.">Method</a> </dd>
<dd>
<a class="el" href="a02189.html#a1b5551dde2821381f3828bfd342cede8" title="Reset all the parameters that have been given before.">resetParams()</a>, <a class="el" href="a02189.html#a9a9b71f0934567a8887a6e8c213e759b" title="Reset the internal data structures and all the parameters that have been given before.">reset()</a> </dd></dl>

</div>
</div>
<a id="a1b5551dde2821381f3828bfd342cede8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b5551dde2821381f3828bfd342cede8">&#9670;&nbsp;</a></span>resetParams()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a02189.html">CycleCanceling</a>&amp; resetParams </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function resets all the paramaters that have been given before using functions <a class="el" href="a02189.html#a980391a01f804f1cd14ac58f365a07af">lowerMap()</a>, <a class="el" href="a02189.html#a0ab69fe04cb7b7ad1bd77acec2c94d46">upperMap()</a>, <a class="el" href="a02189.html#ac890c26d5ecc26854000d2c1e61b8f9b">costMap()</a>, <a class="el" href="a02189.html#a29931e78b92a8e36cf376da50c3d8abb">supplyMap()</a>, <a class="el" href="a02189.html#ad267c7b64da13dfafef5efb8cf9e1671">stSupply()</a>.</p>
<p>It is useful for multiple <a class="el" href="a02189.html#ad63980373b4e743a2827d0a6a0316205">run()</a> calls. Basically, all the given parameters are kept for the next <a class="el" href="a02189.html#ad63980373b4e743a2827d0a6a0316205">run()</a> call, unless <a class="el" href="a02189.html#a1b5551dde2821381f3828bfd342cede8">resetParams()</a> or <a class="el" href="a02189.html#a9a9b71f0934567a8887a6e8c213e759b">reset()</a> is used. If the underlying digraph was also modified after the construction of the class or the last <a class="el" href="a02189.html#a9a9b71f0934567a8887a6e8c213e759b">reset()</a> call, then the <a class="el" href="a02189.html#a9a9b71f0934567a8887a6e8c213e759b">reset()</a> function must be used, otherwise <a class="el" href="a02189.html#a1b5551dde2821381f3828bfd342cede8">resetParams()</a> is sufficient.</p>
<p>For example, </p><div class="fragment"><div class="line">CycleCanceling&lt;ListDigraph&gt; cs(graph);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// First run</span></div>
<div class="line">cc.lowerMap(lower).upperMap(upper).costMap(cost)</div>
<div class="line">  .supplyMap(sup).run();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Run again with modified cost map (resetParams() is not called,</span></div>
<div class="line"><span class="comment">// so only the cost map have to be set again)</span></div>
<div class="line">cost[e] += 100;</div>
<div class="line">cc.costMap(cost).run();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Run again from scratch using resetParams()</span></div>
<div class="line"><span class="comment">// (the lower bounds will be set to zero on all arcs)</span></div>
<div class="line">cc.resetParams();</div>
<div class="line">cc.upperMap(capacity).costMap(cost)</div>
<div class="line">  .supplyMap(sup).run();</div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd><code>(*this)</code></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a02189.html#a9a9b71f0934567a8887a6e8c213e759b" title="Reset the internal data structures and all the parameters that have been given before.">reset()</a>, <a class="el" href="a02189.html#ad63980373b4e743a2827d0a6a0316205" title="Run the algorithm.">run()</a> </dd></dl>

</div>
</div>
<a id="a9a9b71f0934567a8887a6e8c213e759b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a9b71f0934567a8887a6e8c213e759b">&#9670;&nbsp;</a></span>reset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a02189.html">CycleCanceling</a>&amp; reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function resets the internal data structures and all the paramaters that have been given before using functions <a class="el" href="a02189.html#a980391a01f804f1cd14ac58f365a07af">lowerMap()</a>, <a class="el" href="a02189.html#a0ab69fe04cb7b7ad1bd77acec2c94d46">upperMap()</a>, <a class="el" href="a02189.html#ac890c26d5ecc26854000d2c1e61b8f9b">costMap()</a>, <a class="el" href="a02189.html#a29931e78b92a8e36cf376da50c3d8abb">supplyMap()</a>, <a class="el" href="a02189.html#ad267c7b64da13dfafef5efb8cf9e1671">stSupply()</a>.</p>
<p>It is useful for multiple <a class="el" href="a02189.html#ad63980373b4e743a2827d0a6a0316205">run()</a> calls. Basically, all the given parameters are kept for the next <a class="el" href="a02189.html#ad63980373b4e743a2827d0a6a0316205">run()</a> call, unless <a class="el" href="a02189.html#a1b5551dde2821381f3828bfd342cede8">resetParams()</a> or <a class="el" href="a02189.html#a9a9b71f0934567a8887a6e8c213e759b">reset()</a> is used. If the underlying digraph was also modified after the construction of the class or the last <a class="el" href="a02189.html#a9a9b71f0934567a8887a6e8c213e759b">reset()</a> call, then the <a class="el" href="a02189.html#a9a9b71f0934567a8887a6e8c213e759b">reset()</a> function must be used, otherwise <a class="el" href="a02189.html#a1b5551dde2821381f3828bfd342cede8">resetParams()</a> is sufficient.</p>
<p>See <a class="el" href="a02189.html#a1b5551dde2821381f3828bfd342cede8">resetParams()</a> for examples.</p>
<dl class="section return"><dt>Returns</dt><dd><code>(*this)</code></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a02189.html#a1b5551dde2821381f3828bfd342cede8" title="Reset all the parameters that have been given before.">resetParams()</a>, <a class="el" href="a02189.html#ad63980373b4e743a2827d0a6a0316205" title="Run the algorithm.">run()</a> </dd></dl>

</div>
</div>
<a id="a484c946e8ad38f8c0b419c84637140d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a484c946e8ad38f8c0b419c84637140d2">&#9670;&nbsp;</a></span>totalCost()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Number totalCost </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function returns the total cost of the found flow. Its complexity is O(m).</p>
<dl class="section note"><dt>Note</dt><dd>The return type of the function can be specified as a template parameter. For example, <div class="fragment"><div class="line">cc.totalCost&lt;<span class="keywordtype">double</span>&gt;();</div>
</div><!-- fragment --> It is useful if the total cost cannot be stored in the <code>Cost</code> type of the algorithm, which is the default return type of the function.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="a02189.html#ad63980373b4e743a2827d0a6a0316205">run()</a> must be called before using this function. </dd></dl>

</div>
</div>
<a id="a1a77ac91887d3ea35df58e98b13e6fd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a77ac91887d3ea35df58e98b13e6fd4">&#9670;&nbsp;</a></span>flow()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a02189.html#a6c1768456283cc436140a9ffae849dd2">Value</a> flow </td>
          <td>(</td>
          <td class="paramtype">const Arc &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function returns the flow on the given arc.</p>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="a02189.html#ad63980373b4e743a2827d0a6a0316205">run()</a> must be called before using this function. </dd></dl>

</div>
</div>
<a id="aa2ea9eb67aee0565ecdbaeb537eb8b46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2ea9eb67aee0565ecdbaeb537eb8b46">&#9670;&nbsp;</a></span>flowMap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void flowMap </td>
          <td>(</td>
          <td class="paramtype">FlowMap &amp;&#160;</td>
          <td class="paramname"><em>map</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function copies the flow value on each arc into the given map. The <code>Value</code> type of the algorithm must be convertible to the <code>Value</code> type of the map.</p>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="a02189.html#ad63980373b4e743a2827d0a6a0316205">run()</a> must be called before using this function. </dd></dl>

</div>
</div>
<a id="ac291424bc8234750625d26b984442150"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac291424bc8234750625d26b984442150">&#9670;&nbsp;</a></span>potential()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a02189.html#adeb81a88e6bbaf933ca20ea3bbba7a2c">Cost</a> potential </td>
          <td>(</td>
          <td class="paramtype">const Node &amp;&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function returns the potential (dual value) of the given node.</p>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="a02189.html#ad63980373b4e743a2827d0a6a0316205">run()</a> must be called before using this function. </dd></dl>

</div>
</div>
<a id="a0c1faa3dd3a44ffe90e51af832ec7804"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c1faa3dd3a44ffe90e51af832ec7804">&#9670;&nbsp;</a></span>potentialMap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void potentialMap </td>
          <td>(</td>
          <td class="paramtype">PotentialMap &amp;&#160;</td>
          <td class="paramname"><em>map</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function copies the potential (dual value) of each node into the given map. The <code>Cost</code> type of the algorithm must be convertible to the <code>Value</code> type of the map.</p>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="a02189.html#ad63980373b4e743a2827d0a6a0316205">run()</a> must be called before using this function. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a601ffd79f13610daacadd46f973507c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a601ffd79f13610daacadd46f973507c5">&#9670;&nbsp;</a></span>INF</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="a02189.html#a6c1768456283cc436140a9ffae849dd2">Value</a> INF</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constant for infinite upper bounds (capacities). It is <code>std::numeric_limits&lt;Value&gt;::infinity()</code> if available, <code>std::numeric_limits&lt;Value&gt;::max()</code> otherwise. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Apr 22 2021 06:17:54 for My Project by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.20
</small></address>
</body>
</html>
